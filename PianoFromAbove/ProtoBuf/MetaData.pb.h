// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: MetaData.proto

#ifndef PROTOBUF_INCLUDED_MetaData_2eproto
#define PROTOBUF_INCLUDED_MetaData_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3007000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3007001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_MetaData_2eproto

// Internal implementation detail -- do not use these members.
struct TableStruct_MetaData_2eproto {
  static const ::google::protobuf::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::ParseTable schema[4]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
namespace PFAData {
class File;
class FileDefaultTypeInternal;
extern FileDefaultTypeInternal _File_default_instance_;
class FileInfo;
class FileInfoDefaultTypeInternal;
extern FileInfoDefaultTypeInternal _FileInfo_default_instance_;
class MetaData;
class MetaDataDefaultTypeInternal;
extern MetaDataDefaultTypeInternal _MetaData_default_instance_;
class SongInfo;
class SongInfoDefaultTypeInternal;
extern SongInfoDefaultTypeInternal _SongInfo_default_instance_;
}  // namespace PFAData
namespace google {
namespace protobuf {
template<> ::PFAData::File* Arena::CreateMaybeMessage<::PFAData::File>(Arena*);
template<> ::PFAData::FileInfo* Arena::CreateMaybeMessage<::PFAData::FileInfo>(Arena*);
template<> ::PFAData::MetaData* Arena::CreateMaybeMessage<::PFAData::MetaData>(Arena*);
template<> ::PFAData::SongInfo* Arena::CreateMaybeMessage<::PFAData::SongInfo>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace PFAData {

// ===================================================================

class SongInfo :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:PFAData.SongInfo) */ {
 public:
  SongInfo();
  virtual ~SongInfo();

  SongInfo(const SongInfo& from);

  inline SongInfo& operator=(const SongInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SongInfo(SongInfo&& from) noexcept
    : SongInfo() {
    *this = ::std::move(from);
  }

  inline SongInfo& operator=(SongInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const SongInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SongInfo* internal_default_instance() {
    return reinterpret_cast<const SongInfo*>(
               &_SongInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(SongInfo* other);
  friend void swap(SongInfo& a, SongInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SongInfo* New() const final {
    return CreateMaybeMessage<SongInfo>(nullptr);
  }

  SongInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SongInfo>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const SongInfo& from);
  void MergeFrom(const SongInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SongInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes md5 = 1;
  bool has_md5() const;
  void clear_md5();
  static const int kMd5FieldNumber = 1;
  const ::std::string& md5() const;
  void set_md5(const ::std::string& value);
  #if LANG_CXX11
  void set_md5(::std::string&& value);
  #endif
  void set_md5(const char* value);
  void set_md5(const void* value, size_t size);
  ::std::string* mutable_md5();
  ::std::string* release_md5();
  void set_allocated_md5(::std::string* md5);

  // optional int32 division = 2;
  bool has_division() const;
  void clear_division();
  static const int kDivisionFieldNumber = 2;
  ::google::protobuf::int32 division() const;
  void set_division(::google::protobuf::int32 value);

  // optional int32 notes = 3;
  bool has_notes() const;
  void clear_notes();
  static const int kNotesFieldNumber = 3;
  ::google::protobuf::int32 notes() const;
  void set_notes(::google::protobuf::int32 value);

  // optional int32 beats = 4;
  bool has_beats() const;
  void clear_beats();
  static const int kBeatsFieldNumber = 4;
  ::google::protobuf::int32 beats() const;
  void set_beats(::google::protobuf::int32 value);

  // optional int32 seconds = 5;
  bool has_seconds() const;
  void clear_seconds();
  static const int kSecondsFieldNumber = 5;
  ::google::protobuf::int32 seconds() const;
  void set_seconds(::google::protobuf::int32 value);

  // optional int32 tracks = 6;
  bool has_tracks() const;
  void clear_tracks();
  static const int kTracksFieldNumber = 6;
  ::google::protobuf::int32 tracks() const;
  void set_tracks(::google::protobuf::int32 value);

  // optional int32 plays = 7;
  bool has_plays() const;
  void clear_plays();
  static const int kPlaysFieldNumber = 7;
  ::google::protobuf::int32 plays() const;
  void set_plays(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:PFAData.SongInfo)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr md5_;
  ::google::protobuf::int32 division_;
  ::google::protobuf::int32 notes_;
  ::google::protobuf::int32 beats_;
  ::google::protobuf::int32 seconds_;
  ::google::protobuf::int32 tracks_;
  ::google::protobuf::int32 plays_;
  friend struct ::TableStruct_MetaData_2eproto;
};
// -------------------------------------------------------------------

class FileInfo :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:PFAData.FileInfo) */ {
 public:
  FileInfo();
  virtual ~FileInfo();

  FileInfo(const FileInfo& from);

  inline FileInfo& operator=(const FileInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FileInfo(FileInfo&& from) noexcept
    : FileInfo() {
    *this = ::std::move(from);
  }

  inline FileInfo& operator=(FileInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const FileInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FileInfo* internal_default_instance() {
    return reinterpret_cast<const FileInfo*>(
               &_FileInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(FileInfo* other);
  friend void swap(FileInfo& a, FileInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FileInfo* New() const final {
    return CreateMaybeMessage<FileInfo>(nullptr);
  }

  FileInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<FileInfo>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const FileInfo& from);
  void MergeFrom(const FileInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(FileInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .PFAData.SongInfo info = 1;
  bool has_info() const;
  void clear_info();
  static const int kInfoFieldNumber = 1;
  const ::PFAData::SongInfo& info() const;
  ::PFAData::SongInfo* release_info();
  ::PFAData::SongInfo* mutable_info();
  void set_allocated_info(::PFAData::SongInfo* info);

  // @@protoc_insertion_point(class_scope:PFAData.FileInfo)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::PFAData::SongInfo* info_;
  friend struct ::TableStruct_MetaData_2eproto;
};
// -------------------------------------------------------------------

class File :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:PFAData.File) */ {
 public:
  File();
  virtual ~File();

  File(const File& from);

  inline File& operator=(const File& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  File(File&& from) noexcept
    : File() {
    *this = ::std::move(from);
  }

  inline File& operator=(File&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const File& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const File* internal_default_instance() {
    return reinterpret_cast<const File*>(
               &_File_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(File* other);
  friend void swap(File& a, File& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline File* New() const final {
    return CreateMaybeMessage<File>(nullptr);
  }

  File* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<File>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const File& from);
  void MergeFrom(const File& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(File* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string fileName = 1;
  bool has_filename() const;
  void clear_filename();
  static const int kFileNameFieldNumber = 1;
  const ::std::string& filename() const;
  void set_filename(const ::std::string& value);
  #if LANG_CXX11
  void set_filename(::std::string&& value);
  #endif
  void set_filename(const char* value);
  void set_filename(const char* value, size_t size);
  ::std::string* mutable_filename();
  ::std::string* release_filename();
  void set_allocated_filename(::std::string* filename);

  // required int32 fileSize = 2;
  bool has_filesize() const;
  void clear_filesize();
  static const int kFileSizeFieldNumber = 2;
  ::google::protobuf::int32 filesize() const;
  void set_filesize(::google::protobuf::int32 value);

  // required int32 infoPos = 3;
  bool has_infopos() const;
  void clear_infopos();
  static const int kInfoPosFieldNumber = 3;
  ::google::protobuf::int32 infopos() const;
  void set_infopos(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:PFAData.File)
 private:
  class HasBitSetters;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr filename_;
  ::google::protobuf::int32 filesize_;
  ::google::protobuf::int32 infopos_;
  friend struct ::TableStruct_MetaData_2eproto;
};
// -------------------------------------------------------------------

class MetaData :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:PFAData.MetaData) */ {
 public:
  MetaData();
  virtual ~MetaData();

  MetaData(const MetaData& from);

  inline MetaData& operator=(const MetaData& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MetaData(MetaData&& from) noexcept
    : MetaData() {
    *this = ::std::move(from);
  }

  inline MetaData& operator=(MetaData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const MetaData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MetaData* internal_default_instance() {
    return reinterpret_cast<const MetaData*>(
               &_MetaData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(MetaData* other);
  friend void swap(MetaData& a, MetaData& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MetaData* New() const final {
    return CreateMaybeMessage<MetaData>(nullptr);
  }

  MetaData* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MetaData>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const MetaData& from);
  void MergeFrom(const MetaData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(MetaData* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .PFAData.File file = 1;
  int file_size() const;
  void clear_file();
  static const int kFileFieldNumber = 1;
  ::PFAData::File* mutable_file(int index);
  ::google::protobuf::RepeatedPtrField< ::PFAData::File >*
      mutable_file();
  const ::PFAData::File& file(int index) const;
  ::PFAData::File* add_file();
  const ::google::protobuf::RepeatedPtrField< ::PFAData::File >&
      file() const;

  // repeated .PFAData.FileInfo fileInfo = 2;
  int fileinfo_size() const;
  void clear_fileinfo();
  static const int kFileInfoFieldNumber = 2;
  ::PFAData::FileInfo* mutable_fileinfo(int index);
  ::google::protobuf::RepeatedPtrField< ::PFAData::FileInfo >*
      mutable_fileinfo();
  const ::PFAData::FileInfo& fileinfo(int index) const;
  ::PFAData::FileInfo* add_fileinfo();
  const ::google::protobuf::RepeatedPtrField< ::PFAData::FileInfo >&
      fileinfo() const;

  // @@protoc_insertion_point(class_scope:PFAData.MetaData)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::PFAData::File > file_;
  ::google::protobuf::RepeatedPtrField< ::PFAData::FileInfo > fileinfo_;
  friend struct ::TableStruct_MetaData_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// SongInfo

// required bytes md5 = 1;
inline bool SongInfo::has_md5() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SongInfo::clear_md5() {
  md5_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& SongInfo::md5() const {
  // @@protoc_insertion_point(field_get:PFAData.SongInfo.md5)
  return md5_.GetNoArena();
}
inline void SongInfo::set_md5(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  md5_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:PFAData.SongInfo.md5)
}
#if LANG_CXX11
inline void SongInfo::set_md5(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  md5_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:PFAData.SongInfo.md5)
}
#endif
inline void SongInfo::set_md5(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  md5_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:PFAData.SongInfo.md5)
}
inline void SongInfo::set_md5(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  md5_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:PFAData.SongInfo.md5)
}
inline ::std::string* SongInfo::mutable_md5() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:PFAData.SongInfo.md5)
  return md5_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SongInfo::release_md5() {
  // @@protoc_insertion_point(field_release:PFAData.SongInfo.md5)
  if (!has_md5()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return md5_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SongInfo::set_allocated_md5(::std::string* md5) {
  if (md5 != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  md5_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), md5);
  // @@protoc_insertion_point(field_set_allocated:PFAData.SongInfo.md5)
}

// optional int32 division = 2;
inline bool SongInfo::has_division() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SongInfo::clear_division() {
  division_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::int32 SongInfo::division() const {
  // @@protoc_insertion_point(field_get:PFAData.SongInfo.division)
  return division_;
}
inline void SongInfo::set_division(::google::protobuf::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  division_ = value;
  // @@protoc_insertion_point(field_set:PFAData.SongInfo.division)
}

// optional int32 notes = 3;
inline bool SongInfo::has_notes() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SongInfo::clear_notes() {
  notes_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::google::protobuf::int32 SongInfo::notes() const {
  // @@protoc_insertion_point(field_get:PFAData.SongInfo.notes)
  return notes_;
}
inline void SongInfo::set_notes(::google::protobuf::int32 value) {
  _has_bits_[0] |= 0x00000004u;
  notes_ = value;
  // @@protoc_insertion_point(field_set:PFAData.SongInfo.notes)
}

// optional int32 beats = 4;
inline bool SongInfo::has_beats() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SongInfo::clear_beats() {
  beats_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::google::protobuf::int32 SongInfo::beats() const {
  // @@protoc_insertion_point(field_get:PFAData.SongInfo.beats)
  return beats_;
}
inline void SongInfo::set_beats(::google::protobuf::int32 value) {
  _has_bits_[0] |= 0x00000008u;
  beats_ = value;
  // @@protoc_insertion_point(field_set:PFAData.SongInfo.beats)
}

// optional int32 seconds = 5;
inline bool SongInfo::has_seconds() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SongInfo::clear_seconds() {
  seconds_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::google::protobuf::int32 SongInfo::seconds() const {
  // @@protoc_insertion_point(field_get:PFAData.SongInfo.seconds)
  return seconds_;
}
inline void SongInfo::set_seconds(::google::protobuf::int32 value) {
  _has_bits_[0] |= 0x00000010u;
  seconds_ = value;
  // @@protoc_insertion_point(field_set:PFAData.SongInfo.seconds)
}

// optional int32 tracks = 6;
inline bool SongInfo::has_tracks() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SongInfo::clear_tracks() {
  tracks_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::google::protobuf::int32 SongInfo::tracks() const {
  // @@protoc_insertion_point(field_get:PFAData.SongInfo.tracks)
  return tracks_;
}
inline void SongInfo::set_tracks(::google::protobuf::int32 value) {
  _has_bits_[0] |= 0x00000020u;
  tracks_ = value;
  // @@protoc_insertion_point(field_set:PFAData.SongInfo.tracks)
}

// optional int32 plays = 7;
inline bool SongInfo::has_plays() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SongInfo::clear_plays() {
  plays_ = 0;
  _has_bits_[0] &= ~0x00000040u;
}
inline ::google::protobuf::int32 SongInfo::plays() const {
  // @@protoc_insertion_point(field_get:PFAData.SongInfo.plays)
  return plays_;
}
inline void SongInfo::set_plays(::google::protobuf::int32 value) {
  _has_bits_[0] |= 0x00000040u;
  plays_ = value;
  // @@protoc_insertion_point(field_set:PFAData.SongInfo.plays)
}

// -------------------------------------------------------------------

// FileInfo

// required .PFAData.SongInfo info = 1;
inline bool FileInfo::has_info() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FileInfo::clear_info() {
  if (info_ != nullptr) info_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::PFAData::SongInfo& FileInfo::info() const {
  const ::PFAData::SongInfo* p = info_;
  // @@protoc_insertion_point(field_get:PFAData.FileInfo.info)
  return p != nullptr ? *p : *reinterpret_cast<const ::PFAData::SongInfo*>(
      &::PFAData::_SongInfo_default_instance_);
}
inline ::PFAData::SongInfo* FileInfo::release_info() {
  // @@protoc_insertion_point(field_release:PFAData.FileInfo.info)
  _has_bits_[0] &= ~0x00000001u;
  ::PFAData::SongInfo* temp = info_;
  info_ = nullptr;
  return temp;
}
inline ::PFAData::SongInfo* FileInfo::mutable_info() {
  _has_bits_[0] |= 0x00000001u;
  if (info_ == nullptr) {
    auto* p = CreateMaybeMessage<::PFAData::SongInfo>(GetArenaNoVirtual());
    info_ = p;
  }
  // @@protoc_insertion_point(field_mutable:PFAData.FileInfo.info)
  return info_;
}
inline void FileInfo::set_allocated_info(::PFAData::SongInfo* info) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete info_;
  }
  if (info) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      info = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, info, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  info_ = info;
  // @@protoc_insertion_point(field_set_allocated:PFAData.FileInfo.info)
}

// -------------------------------------------------------------------

// File

// required string fileName = 1;
inline bool File::has_filename() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void File::clear_filename() {
  filename_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& File::filename() const {
  // @@protoc_insertion_point(field_get:PFAData.File.fileName)
  return filename_.GetNoArena();
}
inline void File::set_filename(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  filename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:PFAData.File.fileName)
}
#if LANG_CXX11
inline void File::set_filename(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  filename_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:PFAData.File.fileName)
}
#endif
inline void File::set_filename(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  filename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:PFAData.File.fileName)
}
inline void File::set_filename(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  filename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:PFAData.File.fileName)
}
inline ::std::string* File::mutable_filename() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:PFAData.File.fileName)
  return filename_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* File::release_filename() {
  // @@protoc_insertion_point(field_release:PFAData.File.fileName)
  if (!has_filename()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return filename_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void File::set_allocated_filename(::std::string* filename) {
  if (filename != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  filename_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), filename);
  // @@protoc_insertion_point(field_set_allocated:PFAData.File.fileName)
}

// required int32 fileSize = 2;
inline bool File::has_filesize() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void File::clear_filesize() {
  filesize_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::int32 File::filesize() const {
  // @@protoc_insertion_point(field_get:PFAData.File.fileSize)
  return filesize_;
}
inline void File::set_filesize(::google::protobuf::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  filesize_ = value;
  // @@protoc_insertion_point(field_set:PFAData.File.fileSize)
}

// required int32 infoPos = 3;
inline bool File::has_infopos() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void File::clear_infopos() {
  infopos_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::google::protobuf::int32 File::infopos() const {
  // @@protoc_insertion_point(field_get:PFAData.File.infoPos)
  return infopos_;
}
inline void File::set_infopos(::google::protobuf::int32 value) {
  _has_bits_[0] |= 0x00000004u;
  infopos_ = value;
  // @@protoc_insertion_point(field_set:PFAData.File.infoPos)
}

// -------------------------------------------------------------------

// MetaData

// repeated .PFAData.File file = 1;
inline int MetaData::file_size() const {
  return file_.size();
}
inline void MetaData::clear_file() {
  file_.Clear();
}
inline ::PFAData::File* MetaData::mutable_file(int index) {
  // @@protoc_insertion_point(field_mutable:PFAData.MetaData.file)
  return file_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::PFAData::File >*
MetaData::mutable_file() {
  // @@protoc_insertion_point(field_mutable_list:PFAData.MetaData.file)
  return &file_;
}
inline const ::PFAData::File& MetaData::file(int index) const {
  // @@protoc_insertion_point(field_get:PFAData.MetaData.file)
  return file_.Get(index);
}
inline ::PFAData::File* MetaData::add_file() {
  // @@protoc_insertion_point(field_add:PFAData.MetaData.file)
  return file_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::PFAData::File >&
MetaData::file() const {
  // @@protoc_insertion_point(field_list:PFAData.MetaData.file)
  return file_;
}

// repeated .PFAData.FileInfo fileInfo = 2;
inline int MetaData::fileinfo_size() const {
  return fileinfo_.size();
}
inline void MetaData::clear_fileinfo() {
  fileinfo_.Clear();
}
inline ::PFAData::FileInfo* MetaData::mutable_fileinfo(int index) {
  // @@protoc_insertion_point(field_mutable:PFAData.MetaData.fileInfo)
  return fileinfo_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::PFAData::FileInfo >*
MetaData::mutable_fileinfo() {
  // @@protoc_insertion_point(field_mutable_list:PFAData.MetaData.fileInfo)
  return &fileinfo_;
}
inline const ::PFAData::FileInfo& MetaData::fileinfo(int index) const {
  // @@protoc_insertion_point(field_get:PFAData.MetaData.fileInfo)
  return fileinfo_.Get(index);
}
inline ::PFAData::FileInfo* MetaData::add_fileinfo() {
  // @@protoc_insertion_point(field_add:PFAData.MetaData.fileInfo)
  return fileinfo_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::PFAData::FileInfo >&
MetaData::fileinfo() const {
  // @@protoc_insertion_point(field_list:PFAData.MetaData.fileInfo)
  return fileinfo_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace PFAData

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // PROTOBUF_INCLUDED_MetaData_2eproto
